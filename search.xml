<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>欢迎光临~</title>
    <url>/2024/05/29/first/</url>
    <content><![CDATA[<p>一个热爱前端开发的代码战士，在这里会记录我的学习历程，工作经验，以及一些个人爱好。</p>
]]></content>
      <categories>
        <category>简介</category>
      </categories>
  </entry>
  <entry>
    <title>nest.js学习笔记1</title>
    <url>/2024/06/06/nest_1/</url>
    <content><![CDATA[<h2 id="1-nest-js学习笔记"><a href="#1-nest-js学习笔记" class="headerlink" title="1 nest.js学习笔记"></a>1 nest.js学习笔记</h2><h2 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">- Node.js（版本 &gt;= 16）</span><br><span class="line">- npm i -g @nestjs/cli </span><br><span class="line">- nest new project-name --strict //加strict生成ts模版</span><br><span class="line">- 要避免生成测试文件，您可以使用--no-spec标志，如下所示：nest g resource users --no-spec</span><br><span class="line">- 如安装后报Delete `␍` eslint(prettier/prettier) =&gt; yarn run lint --fix</span><br></pre></td></tr></table></figure></div>
<h3 id="1-1-文件名称概要"><a href="#1-1-文件名称概要" class="headerlink" title="1.1 文件名称概要"></a>1.1 文件名称概要</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">- app.controller.ts  //单一路由的基本控制器</span><br><span class="line">- app.controller.spec.ts  //控制器的单元测试</span><br><span class="line">- app.module.ts  //应用程序的根模块.</span><br><span class="line">- app.service.ts  //基本服务</span><br><span class="line">- main.ts //入口文件</span><br></pre></td></tr></table></figure></div>
<h3 id="1-2-main-ts"><a href="#1-2-main-ts" class="headerlink" title="1.2 main.ts"></a>1.2 main.ts</h3><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">NestFactory</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/core&#x27;</span>;</span><br><span class="line"><span class="comment">// 导入核心类,访问create</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">AppModule</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./app.module&#x27;</span>;</span><br><span class="line"><span class="comment">// AppModule 是应用程序的模块类，它定义了应用程序的依赖和组件。</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">bootstrap</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">await</span> <span class="title class_">NestFactory</span>.<span class="title function_">create</span>(<span class="title class_">AppModule</span>);</span><br><span class="line">  <span class="keyword">await</span> app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//然后，使用 await app.listen(3000) 启动应用程序监听器，并在端口 3000 上等待请求。</span></span><br><span class="line"><span class="title function_">bootstrap</span>();</span><br></pre></td></tr></table></figure></div>

<h2 id="2-控制器"><a href="#2-控制器" class="headerlink" title="2 控制器"></a>2 控制器</h2><p>&nbsp;&nbsp;控制器是接收应用程序的特定请求。<br /><br>&nbsp;&nbsp;每个控制器的可以有多个路由，在不同的路由内实现不同的操作。（在egg.js中是可以调用service或者获取ctx中的params等数据，再返回数据。）</p>
<blockquote>
<p>快速创建带有CRUD控制器，使用CLI的CRUD生成器：nest g resource [name]。</p>
</blockquote>
<p>Tips(生成的控制器选项)：<br /><br>   生成的服务类不绑定到任何特定的ORM（或数据源），加–no-spec标志可以避免生成测试文件</p>
<ol>
<li>REST.api &#x3D;&gt;  为所有 CRUD 选项（REST API 的路由、GraphQL 的查询和突变、微服务和 WebSocket 网关的消息订阅）创建占位符，如下.<div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">//偷个懒在代码块进行笔记</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Controller</span>,<span class="title class_">Get</span>,<span class="title class_">Post</span>,<span class="title class_">Body</span>,<span class="title class_">Patch</span>,<span class="title class_">Param</span>,<span class="title class_">Delete</span>,&#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="comment">//装饰器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">UserService</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./user.service&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">CreateUserDto</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./dto/create-user.dto&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">UpdateUserDto</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./dto/update-user.dto&#x27;</span>;</span><br><span class="line"><span class="comment">//装饰器 ，在此修饰后，请求http://localhost:3000/user，即访问此路由。也可以使用通配符修饰如： ab*cd</span></span><br><span class="line"><span class="comment">// 子域路由，使用host选项，以要求传入请求的HTTP主机与某个特定值匹配</span></span><br><span class="line"><span class="comment">//@Controller(&#123; host: &#x27;www.baidu.com&#x27; &#125;)</span></span><br><span class="line"><span class="meta">@Controller</span>(<span class="string">&#x27;user&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> <span class="keyword">readonly</span> userService: UserService</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Post</span>()</span><br><span class="line">  <span class="comment">//状态码，正常的请求默认为200，POST请求的状态码为201。在此我们可以进行修改，状态码不是静态的，可以使用特定库进行相应，使用@Res()进行注入，</span></span><br><span class="line"><span class="comment">//或者抛出错误，throw error; // 抛出之前定义的值（例如，在 catch 块中）</span></span><br><span class="line"><span class="comment">//new Promise((resolve, reject) =&gt; &#123;</span></span><br><span class="line"><span class="comment">// if (err) &#123;</span></span><br><span class="line"><span class="comment">//       reject(err);</span></span><br><span class="line"><span class="comment">//      &#125;</span></span><br><span class="line"><span class="comment">//      resolve(data);</span></span><br><span class="line"><span class="comment">//  &#125;);</span></span><br><span class="line"><span class="comment">//throw new Error(&quot;Required&quot;); // 抛出一个新的错误对象</span></span><br><span class="line"><span class="meta">@HttpCode</span>(<span class="number">204</span>)</span><br><span class="line"><span class="comment">//修改头部</span></span><br><span class="line"><span class="meta">@Header</span>(<span class="string">&#x27;Cache-Control&#x27;</span>, <span class="string">&#x27;none&#x27;</span>)</span><br><span class="line"><span class="comment">//重定向问题：示例，接受两个参数，url和状态码，也可以在方法内进行定向如下</span></span><br><span class="line"><span class="meta">@Redirect</span>(<span class="string">&#x27;https://xxx.com&#x27;</span>, <span class="number">301</span>)</span><br><span class="line"></span><br><span class="line">  <span class="title function_">create</span>(<span class="params"><span class="meta">@Body</span>() createUserDto: CreateUserDto</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">5</span> === <span class="string">&#x27;5&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">url</span>: <span class="string">&#x27;http://nestjs.inode.club/v5/&#x27;</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">userService</span>.<span class="title function_">create</span>(createUserDto);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Get</span>()</span><br><span class="line">  <span class="title function_">findAll</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">userService</span>.<span class="title function_">findAll</span>();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 路由参数，获取传递的动态数据</span></span><br><span class="line">  <span class="meta">@Get</span>(<span class="string">&#x27;:id&#x27;</span>)</span><br><span class="line">  <span class="title function_">findOne</span>(<span class="params"><span class="meta">@Param</span>(<span class="string">&#x27;id&#x27;</span>) id: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">userService</span>.<span class="title function_">findOne</span>(+id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Patch</span>(<span class="string">&#x27;:id&#x27;</span>)</span><br><span class="line">  <span class="title function_">update</span>(<span class="params"><span class="meta">@Param</span>(<span class="string">&#x27;id&#x27;</span>) id: <span class="built_in">string</span>, <span class="meta">@Body</span>() updateUserDto: UpdateUserDto</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">userService</span>.<span class="title function_">update</span>(+id, updateUserDto);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Delete</span>(<span class="string">&#x27;:id&#x27;</span>)</span><br><span class="line">  <span class="title function_">remove</span>(<span class="params"><span class="meta">@Param</span>(<span class="string">&#x27;id&#x27;</span>) id: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">userService</span>.<span class="title function_">remove</span>(+id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></li>
<li>Microservice 微服务</li>
<li>GraphQL 解析器(代码优先和模式优先)</li>
<li>WebSocket 网关</li>
</ol>
<h3 id="2-1-作用域"><a href="#2-1-作用域" class="headerlink" title="2.1 作用域"></a>2.1 作用域</h3><blockquote>
<p>1.<a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Glossary/Scope" >对于JS作用域，可看MDN <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br /><br>2.<a class="link"   href="https://nestjs.inode.club/fundamentals/injection-scopes#%E6%8F%90%E4%BE%9B%E8%80%85%E4%BD%9C%E7%94%A8%E5%9F%9F" >对于nest的作用域，可自行浏览 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<ol>
<li>DEFAULT：单一实例在整个应用程序中共享。实例的生命周期直接与应用程序的生命周期相关联。</li>
<li>REQUEST：为每个传入请求创建一个该提供者的新实例。实例会在请求完成处理后进行垃圾回收。</li>
<li>TRANSIENT: 瞬态提供者在不同的消费者之间不共享。每个注入瞬态提供者的消费者都会收到一个新的、专用的实例。</li>
</ol>
<h3 id="2-2-请求负载"><a href="#2-2-请求负载" class="headerlink" title="2.2 请求负载"></a>2.2 请求负载</h3><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用ts需要确定DTO（数据传输对象）模式，DTO是一个定义了数据将如何通过网络发送的对象。</span></span><br><span class="line"><span class="comment">//为什么使用类：类是JavaScript ES6标准的一部分，因此它们在编译后的JavaScript中被保留为实际实体。另一方面，由于TypeScript接口在编译过程中被删除，Nest无法在运行时引用。</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">CreateUserDTO</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">gender</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用时</span></span><br><span class="line"><span class="meta">@Post</span>()</span><br><span class="line"><span class="keyword">async</span> <span class="title function_">create</span>(<span class="params"><span class="meta">@Body</span>() CreateUserDTO: CreateUserDTO</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;This action adds a new person&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="2-3-异常过滤器"><a href="#2-3-异常过滤器" class="headerlink" title="2.3 异常过滤器"></a>2.3 异常过滤器</h3><blockquote>
<p><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Glossary/Scope" >Nest框架内置了一个异常处理层 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br /></p>
</blockquote>
]]></content>
      <categories>
        <category>node学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>nest.js学习笔记</title>
    <url>/2024/06/03/nest/</url>
    <content><![CDATA[<blockquote>
<p>一直想系统学习一个node的框架，之前有写过一个egg.js的考勤，因为ts的使用越来越多，所以想换个新的框架进行学习。 <br/> </p>
</blockquote>
<h2 id="1-框架"><a href="#1-框架" class="headerlink" title="1.框架"></a>1.框架</h2><p>&nbsp; &nbsp; Nest.js、Egg.js 和 Koa 都是基于 Node.js 的服务端框架，但它们的设计和使用场景有所不同。</p>
<h3 id="1-1-Nest-js"><a href="#1-1-Nest-js" class="headerlink" title="1.1 Nest.js"></a>1.1 Nest.js</h3><p>&nbsp; &nbsp; 结合了面向对象编程（OOP）和函数式反应式编程（FRP）的概念，提供了结构化和模块化的项目结构。Nest 自带了一些基本功能，如依赖注入、装饰器、以及对 Express 和 GraphQL 的支持,可扩展的微服务和企业级应用。<br/><br>&nbsp; &nbsp;适合构建大型、结构化的应用，尤其是那些需要严格代码组织和高可维护性的项目。</p>
<h3 id="1-2-egg-js"><a href="#1-2-egg-js" class="headerlink" title="1.2 egg.js"></a>1.2 egg.js</h3><p>&nbsp; &nbsp; 基于 Koa，提供了更多的开箱即用的功能，比如插件系统、命令行工具、配置管理、日志处理等。<br/><br>&nbsp; &nbsp;适合中大型企业应用，尤其是需要快速搭建稳定、可扩展的基础架构的情况。</p>
<h3 id="1-3-Koa-js"><a href="#1-3-Koa-js" class="headerlink" title="1.3 Koa.js"></a>1.3 Koa.js</h3><p>&nbsp; &nbsp; 通过使用 ES6 的特性（如生成器或 async&#x2F;await）来简化异步处理，并且不内置任何中间件，提供了一个干净的、无偏见的基础，让开发者自由选择需要的组件。<br/><br>&nbsp; &nbsp;适合快速开发原型、小型应用或者需要高度定制化的项目。</p>
]]></content>
      <categories>
        <category>node学习笔记</category>
      </categories>
  </entry>
</search>
